// Architecture: 

    UI          <==>            Bloc            <==>        Data
    
    Presentation            Business Logic                  Data
    Layer                   Layer                           Layer


DATA LAYER: Repositories <=> Data Providers  <=> Models

Model: It is a blueprint to the data your application will work with.
    A model should not be completely linked to the data.
    Should be independent of the source
    Should be Generic and Universal to the multiple data sources.

Data Provider: Provides the raw data to the repository sublayer.
    Eg. APIs to fetch the data from the internet (http.get, http.post etc)
    The return type of the API class functions should not be the MODEL, but type of the RAW Data received from the data source.

REPOSITORY: Part of data layer through wich Bloc communicates. Prepares the data and sends it to the Bloc layer.
    Wrapper around one or more Data Providers.
    Model classes are instantiated as objects here.
    A class which contains dependencies of their respective data providers.



BUSINESS LOGIC LAYER:
    Intermediate bw Presentation layer and Data layer
    
PRESENTATION LAYER:

------

FOLDER STRUCTURE:
data
    > dataproviders
    > models
    > repositories
business_logic
    > blocs
    > cubits
presentation
    > pages
    > widgets
    > animaations

FOLDER STRUCTURE (Updated):
lib/
    core/
        > constants
            # api_path
        > resources
            # exceptions, failure, result
        > services
        > usecases
            # usecase (abstract generic class)
        > util
            # db, logger
    feature/
        data
            > datasources
            > models
            > repositories (repository impl)
        domain
            > entities
            > repositories (abstract classes)
            > usecases
        presentation
            > blocs
            > cubits
            > pages
            > widgets
            > animations
    


1. Domain Layer (Core Business Logic)
    The domain layer is the heart of the application where all the core business logic resides. It's independent of external libraries and frameworks like Flutter, APIs, or databases. This layer should focus solely on representing and implementing the essential features of your app, using abstractions (interfaces) for external dependencies.

    Entities: Represent the core business models. For example, a User, Product, or Order class.
    Repositories (Interfaces): Abstract interfaces that define how data is fetched or stored. These repositories are implemented in the data layer but are declared in the domain layer.
    Use Cases/Interactors: Encapsulate specific business logic. Each use case should define a piece of functionality for the application (e.g., LoginUserUseCase, FetchProductsUseCase).

    Order of Implementation:
    Start with Entities: These are the foundational models that the rest of your app depends on.
    Define Repository Interfaces: Set up the contracts for how the data layer should interact with the domain layer (e.g., methods like getUser(), getProducts()).
    Implement Use Cases: Define business logic related to your entities.

2. Data Layer (Data Management)
    The data layer is responsible for fetching data from external sources (e.g., APIs, databases, local storage) and providing it to the domain layer. It implements the repository interfaces defined in the domain layer.

    Models: Data models used to transfer data between the layers (e.g., API response models).
    Data Sources: Classes or services that manage interaction with external data sources (e.g., RemoteDataSource, LocalDataSource).
    Repository Implementations: The concrete classes that implement the repository interfaces and fetch data from external sources (e.g., an API client, database, or local storage).

    Order of Implementation:
    Create Models: Define the data models that will be used to communicate with the domain layer and external sources.
    Create Data Sources: Implement the actual logic to fetch data (e.g., from an API or a database).
    Implement Repository Interfaces: Create the concrete classes that implement the repository methods from the domain layer.

3. Presentation Layer (UI and Interaction)
    The presentation layer is responsible for handling user interface and interaction. This layer uses the use cases from the domain layer to perform the business logic and then update the UI accordingly.

    View Models: A layer between the UI and the domain layer. It retrieves data via use cases and prepares it for display in the UI.
    State Management: Classes that manage the state of the UI, typically using a state management solution (e.g., Provider, Riverpod, Bloc, setState).
    UI Screens: Widgets that represent the different screens of the app (e.g., HomeScreen, LoginScreen).

    Order of Implementation:
    Implement State Management(Bloc): Set up the state management solution for handling UI updates and user interactions.
    Connect with Use Cases: Use the use cases from the domain layer to retrieve and manipulate data for display in the UI.
    Create UI Screens: Define the layout and structure of your screens.
